import { supabase } from "../lib/supabase";
import {
  Workout,
  TrainingSession,
  DailyLog,
  Exercise,
  SetData,
} from "../types";

export const db = {
  // --- Workouts ---

  getWorkouts: async (): Promise<Workout[]> => {
    const { data: workoutsData, error: workoutsError } = await supabase
      .from("workouts")
      .select(
        `
        id,
        name,
        workout_exercises (
          id,
          order_index,
          target_sets,
          exercises (
            id,
            name,
            default_sets,
            has_warmup
          )
        )
      `
      )
      .eq("is_archived", false)
      .order("created_at", { ascending: true });

    if (workoutsError) throw workoutsError;

    return workoutsData.map((w: any) => ({
      id: w.id,
      name: w.name,
      exercises: w.workout_exercises
        .sort((a: any, b: any) => a.order_index - b.order_index)
        .map((we: any) => ({
          id: we.exercises.id,
          name: we.exercises.name,
          sets: we.target_sets || we.exercises.default_sets,
          hasWarmup: we.exercises.has_warmup,
        })),
    }));
  },

  saveWorkout: async (workout: Workout) => {
    const { data: userData } = await supabase.auth.getUser();
    if (!userData.user) throw new Error("User not logged in");

    // 1. Upsert Workout
    const { data: savedWorkout, error: workoutError } = await supabase
      .from("workouts")
      .upsert({
        id: workout.id,
        user_id: userData.user.id,
        name: workout.name,
      })
      .select()
      .single();

    if (workoutError) throw workoutError;

    // 2. Handle Exercises
    // We need to ensure exercises exist in the 'exercises' table.
    // In this simple version, we assume exercises might be new or existing.
    // If we want to support custom exercises, we should upsert them first.

    // For now, let's assume we first ensure all exercises exist.
    // But since 'Exercise' type has ID, maybe we assume they are already picked.
    // If the user creates a NEW exercise in the UI, it should probably be saved to 'exercises' first.
    // Let's iterate and upsert exercises just in case (if ID is new/generated by client).
    // Note: The UI generates UUIDs for everything currently.

    // However, workout_exercises links workout_id and exercise_id.
    // We first delete existing links for this workout to simpler 'replace' logic (or we can smart diff).
    // Simple replace:
    await supabase
      .from("workout_exercises")
      .delete()
      .eq("workout_id", workout.id);

    const workoutExercises = await Promise.all(
      workout.exercises.map(async (ex, index) => {
        // Ensure exercise exists
        await supabase
          .from("exercises")
          .upsert({
            id: ex.id,
            user_id: userData.user?.id,
            name: ex.name,
            default_sets: ex.sets,
            has_warmup: ex.hasWarmup,
          })
          .select();

        return {
          workout_id: workout.id,
          exercise_id: ex.id,
          order_index: index,
          target_sets: ex.sets,
        };
      })
    );

    const { error: linksError } = await supabase
      .from("workout_exercises")
      .insert(workoutExercises);

    if (linksError) throw linksError;
  },

  deleteWorkout: async (id: string) => {
    const { error } = await supabase
      .from("workouts")
      .update({ is_archived: true }) // Soft delete
      .eq("id", id);
    if (error) throw error;
  },

  // --- Training Sessions ---

  getTrainings: async (): Promise<TrainingSession[]> => {
    const { data, error } = await supabase
      .from("training_sessions")
      .select(
        `
        id,
        workout_id,
        date,
        start_time,
        end_time,
        session_sets (
          id,
          exercise_id,
          set_number,
          reps,
          weight,
          is_warmup,
          completed
        )
      `
      )
      .order("date", { ascending: true });

    if (error) throw error;

    return data.map((s: any) => {
      // Group sets by exercise_id
      const exerciseResults: Record<string, SetData[]> = {};
      s.session_sets.forEach((set: any) => {
        if (!exerciseResults[set.exercise_id]) {
          exerciseResults[set.exercise_id] = [];
        }
        exerciseResults[set.exercise_id].push({
          reps: set.reps,
          weight: set.weight,
          isWarmup: set.is_warmup,
          completed: set.completed,
        });
      });
      // Sort sets by set_number is implicit if we inserted them in order, but good to be safe.
      // But we lost set_number in the map, assuming order is preserved or we should sort.
      // Let's trust the grouping for now or enhance.

      return {
        id: s.id,
        workoutId: s.workout_id,
        date: s.date,
        startTime: s.start_time ? new Date(s.start_time).getTime() : undefined,
        endTime: s.end_time ? new Date(s.end_time).getTime() : undefined,
        exerciseResults,
      };
    });
  },

  saveTraining: async (session: TrainingSession) => {
    const { data: userData } = await supabase.auth.getUser();
    if (!userData.user) throw new Error("User not logged in");

    // 1. Insert Session
    const { error: sessionError } = await supabase
      .from("training_sessions")
      .upsert({
        id: session.id,
        user_id: userData.user.id,
        workout_id: session.workoutId,
        date: session.date,
        start_time: session.startTime
          ? new Date(session.startTime).toISOString()
          : null,
        end_time: session.endTime
          ? new Date(session.endTime).toISOString()
          : null,
      });

    if (sessionError) throw sessionError;

    // 2. Insert Sets
    // Flatten the dictionary
    const setsToInsert: any[] = [];

    // First delete existing sets if updating
    await supabase.from("session_sets").delete().eq("session_id", session.id);

    Object.entries(session.exerciseResults).forEach(([exerciseId, sets]) => {
      sets.forEach((set, index) => {
        setsToInsert.push({
          session_id: session.id,
          exercise_id: exerciseId,
          set_number: index + 1,
          reps: set.reps,
          weight: set.weight,
          is_warmup: set.isWarmup,
          completed: set.completed,
        });
      });
    });

    if (setsToInsert.length > 0) {
      const { error: setsError } = await supabase
        .from("session_sets")
        .insert(setsToInsert);
      if (setsError) throw setsError;
    }
  },

  // --- Daily Logs ---

  getDailyLogs: async (): Promise<DailyLog[]> => {
    const { data, error } = await supabase
      .from("daily_logs")
      .select("*")
      .order("date", { ascending: true });

    if (error) throw error;

    return data.map((l: any) => ({
      id: l.id,
      date: l.date,
      weight: l.weight,
      calories: l.calories,
    }));
  },

  saveDailyLog: async (log: DailyLog) => {
    const { data: userData } = await supabase.auth.getUser();
    if (!userData.user) throw new Error("User not logged in");

    const { error } = await supabase.from("daily_logs").upsert({
      id: log.id,
      user_id: userData.user.id,
      date: log.date,
      weight: log.weight,
      calories: log.calories,
    });

    if (error) throw error;
  },
};
